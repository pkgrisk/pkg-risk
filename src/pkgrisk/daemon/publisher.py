"""GitHub publisher for automatic data updates."""

from __future__ import annotations

import asyncio
import logging
import subprocess
import sys
from datetime import datetime, timezone
from pathlib import Path

logger = logging.getLogger(__name__)


class GitHubPublisher:
    """Handles rebuilding frontend data and pushing to GitHub.

    Tracks packages analyzed since last publish and triggers
    a publish cycle after reaching the configured threshold.

    A publish cycle:
    1. Runs scripts/build_frontend_data.py to regenerate data files
    2. Stages changes with git add
    3. Commits with a descriptive message
    4. Pushes to the remote repository
    """

    def __init__(
        self,
        repo_dir: Path = Path("."),
        publish_interval: int = 50,
    ) -> None:
        """Initialize the publisher.

        Args:
            repo_dir: Root directory of the git repository
            publish_interval: Number of packages between publishes
        """
        self.repo_dir = repo_dir
        self.publish_interval = publish_interval
        self._packages_since_publish = 0
        self._last_publish: datetime | None = None
        self._total_published = 0

    def record_package(self) -> None:
        """Record that a package was analyzed."""
        self._packages_since_publish += 1

    async def maybe_publish(self) -> bool:
        """Publish if enough packages have been analyzed.

        Returns:
            True if a publish was performed, False otherwise
        """
        if self._packages_since_publish < self.publish_interval:
            return False

        await self.force_publish()
        return True

    async def force_publish(self) -> None:
        """Force an immediate publish regardless of threshold.

        This is called on graceful shutdown to ensure all pending
        changes are pushed.
        """
        if self._packages_since_publish == 0:
            logger.info("No packages to publish")
            return

        count = self._packages_since_publish
        logger.info(f"Publishing {count} packages to GitHub...")

        try:
            # Step 1: Build frontend data
            await self._run_build_script()

            # Step 2: Stage, commit, and push
            await self._git_commit_and_push(count)

            self._last_publish = datetime.now(timezone.utc)
            self._total_published += count
            self._packages_since_publish = 0

            logger.info(f"Successfully published {count} packages")

        except Exception as e:
            logger.error(f"Publish failed: {e}")
            # Don't reset counter on failure - will retry next time

    async def _run_build_script(self) -> None:
        """Run the frontend data build script."""
        script_path = self.repo_dir / "scripts" / "build_frontend_data.py"

        if not script_path.exists():
            raise FileNotFoundError(f"Build script not found: {script_path}")

        logger.debug("Running build_frontend_data.py...")

        proc = await asyncio.create_subprocess_exec(
            sys.executable,
            str(script_path),
            cwd=str(self.repo_dir),
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
        )

        stdout, stderr = await proc.communicate()

        if proc.returncode != 0:
            error_msg = stderr.decode() if stderr else "Unknown error"
            raise RuntimeError(f"Build script failed: {error_msg}")

        logger.debug("Build script completed successfully")

    async def _git_commit_and_push(self, package_count: int) -> None:
        """Stage, commit, and push changes to GitHub."""
        # Check if there are any changes to commit
        result = await self._run_git("status", "--porcelain", "frontend/public/data/")
        if not result.strip():
            logger.info("No changes to commit")
            return

        # Stage changes
        await self._run_git("add", "frontend/public/data/")

        # Create commit message
        timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M UTC")
        message = f"Update analysis data ({package_count} packages)\n\nAuto-generated by pkgrisk daemon at {timestamp}"

        # Commit
        await self._run_git("commit", "-m", message)

        # Push
        await self._run_git("push")

        logger.info("Changes pushed to GitHub")

    async def _run_git(self, *args: str) -> str:
        """Run a git command and return output.

        Args:
            *args: Git command arguments

        Returns:
            Command stdout

        Raises:
            RuntimeError: If git command fails
        """
        proc = await asyncio.create_subprocess_exec(
            "git",
            *args,
            cwd=str(self.repo_dir),
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
        )

        stdout, stderr = await proc.communicate()

        if proc.returncode != 0:
            error_msg = stderr.decode() if stderr else "Unknown error"
            raise RuntimeError(f"git {args[0]} failed: {error_msg}")

        return stdout.decode()

    def get_status(self) -> dict:
        """Get current publisher status."""
        return {
            "packages_since_publish": self._packages_since_publish,
            "publish_interval": self.publish_interval,
            "last_publish": (
                self._last_publish.isoformat() if self._last_publish else None
            ),
            "total_published": self._total_published,
        }
